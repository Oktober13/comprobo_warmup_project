#!/usr/bin/env python
""" Avoids obstacles. """

import atexit
import math
import matplotlib.pyplot as plt
import numpy as np
import rospy
import warnings

from geometry_msgs.msg import Vector3
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Point
from neato_node.msg import Bump
from nav_msgs.msg import Odometry
from scipy.stats import norm
from sklearn.cluster import DBSCAN
from std_msgs.msg import ColorRGBA
from std_msgs.msg import Header
from sensor_msgs.msg import LaserScan
from visualization_msgs.msg import Marker

from person_follower import NeatoCallbacks
from rosnode_testmarker import RVizMarker
from wall_follower import WallFollower
from person_follower import PersonFollower

class APF(object):
	""" The artificial potential field algorithm. """
	def __init__(self):
		self.probabilityList = 360 * [0] # 360 degrees. The list of navigational probability for moving at a certain angle.
		pass

	"""
		Generates a normal probability distribution centered around mean mu and with a standard deviation, or spread, of sigma.
		Scaled by the input weight.
	"""
	def normalPDF(self, mu, sigma, weight):
		for x in range(-4, 4): # 99.7% of probability falls within 3 standard deviations of mean (-3,-2,-1,0,1,2,3)
			# Find equation here: https://docs.scipy.org/doc/numpy-1.14.0/reference/generated/numpy.random.normal.html
			self.probabilityList[int(round(mu)) + x] = (weight / (sigma * np.sqrt(2 * np.pi)) * np.exp( - (x)**2 / (2 * sigma**2)))
		return

	def generateProbability(self, obstCoordDict, goalAngle):
		for obstAngle in obstCoordDict.keys():
			self.normalPDF(obstAngle, 15, -1) # centered around obstAngle (degrees) with stdev of +/- 5 degrees and a weight of 1. 
		self.normalPDF(goalAngle, 30, 1) # centered around goalAngle (degrees) with stdev of +/- 10 degrees and a weight of 1.
		# Goal's probability distributions will be somewhat more "diluted" than any obstacles' PDF, because goal has 2x stdev but the same weight.
		return

	def normalizeProbability(self):
		maxProb = max(self.probabilityList)
		self.probabilityList[:] = [prob / maxProb for prob in self.probabilityList]
		return

	def bestAngle(self, obstCoordDict, goalAngle):
		self.probabilityList = 360 * [0]
		self.generateProbability(obstCoordDict, goalAngle) # generate PDF for all obstacles and for goal.
		self.normalizeProbability()
		return np.argmax(self.probabilityList), min(obstCoordDict.values())

	def visualizePDF(self): # Display complete probability graph for 0-360 degrees.
		plt.plot(range(len(self.probabilityList)), self.probabilityList, linewidth=1, color='r')
		plt.title('Navigational probability')
		plt.xlabel('Angle')
		plt.ylabel('Probability')
		plt.show()
		return

class ObstacleAvoid(object):
	""" Avoids obstacles using Artificial Potential Field. """
	def __init__(self):
		self.velPub = rospy.Publisher("/cmd_vel", Twist, queue_size = 10)
		self.vizPub = rospy.Publisher('/marker', Marker, queue_size = 10)

		self.vel = Twist(Vector3(0.05, 0.00, 0.00), Vector3(0.00, 0.00, 0.00))
		self.stopVel = Twist(Vector3(0.00, 0.00, 0.00), Vector3(0.00, 0.00, 0.00))

		self.obstCoordDict = {}

		self.r = rospy.Rate(10)

		self.dbsc = None
		self.labels = None
		self.lidarPoints = None
		self.pGain = 0.03 #Temp

		atexit.register(self.exitHandler)

	def findClusters(self, datapoints, neighborhood, minSamples):
		# Density cluster similar datapoints using DBSCAN
		# documentation: https://stackoverflow.com/questions/18237479/dbscan-in-scikit-learn-of-python-save-the-cluster-points-in-an-array
		self.dbsc = DBSCAN(eps = neighborhood, min_samples = minSamples).fit(datapoints)
		self.labels = self.dbsc.labels_
		core_samples = np.zeros_like(self.labels, dtype = bool)
		core_samples[self.dbsc.core_sample_indices_] = True

		# Number of clusters in labels, ignoring noise if present.
		n_clusters_ = len(set(self.labels)) - (1 if -1 in self.labels else 0)
		# print "clusters: " + str(n_clusters_)

		# Find angle,distance (x,y) of clusters generated by DBSCAN
		clusters = [np.mean(datapoints[self.labels == i],axis=0) for i in xrange(n_clusters_)]
		return clusters

	def findObstacles(self, lidarScan):
		# Compiles list of all obstacles from (angle,distance) cluster-center coords returned by findClusters
		if lidarScan is not None:
			self.obstCoordDict = {}

			self.lidarPoints = np.empty([361,2])
			for angle in range(len(lidarScan)): # Convert angle and distance data to positional data
				x = lidarScan[angle] * math.cos((angle * math.pi) / 180.0 )
				y = lidarScan[angle] * math.sin((angle * math.pi) / 180.0 )
				self.lidarPoints[angle] = x,y

			# Find clusters with dbscan
			coordinates = self.findClusters(self.lidarPoints, 0.2, 3)

			# Add cluster coordinate (angle, laser range distance) to dictionary of obstacles if the distance is less than 1 m.
			for point in coordinates:
				[x,y] = point
				angle = ((180 * math.atan2(y, x)) / math.pi)
				if angle < 0: angle = angle + 360
				self.obstCoordDict[angle] = math.sqrt(x**2 + y**2)
			del self.obstCoordDict[0]
		return

	def angleToGoal(self, data, coordinates):
		# 0 degrees is the front of the Neato; degrees increase counterclockwise. (Polar coordinates)
		goalAngle = math.atan2((coordinates.y - data.position.y), (coordinates.x - data.position.x))
		goalAngle = 180 * goalAngle / math.pi # Convert from radians to degrees
		return goalAngle

	def navigate(self, angle, distance, maxSpeed):
		yawError = angle

		if (abs(yawError) >= (2 * (math.pi / 18.0))): # Turn is prioritized when error in drive angle is >= +/-20 degrees
			self.vel.linear.x = 0.0
		else: # Error is acceptable: move forward
			self.vel.linear.x = maxSpeed

		print yawError

		self.vel.angular.z = WallFollower.PID(self.vel.angular.z, self.pGain, yawError)
		return

	def laserscanVisualizer(self, datapoints):
		unique_labels = set(self.labels)
		colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_labels))]

		# plt.scatter(datapoints.ranges.keys(), datapoints.ranges.values(), c=self.labels, s=40, cmap='viridis')
		for k, col in zip(unique_labels, colors):
			if k == -1:
				# Black used for noise.
				col = [0, 0, 0, 1]

			core_samples_mask = np.zeros_like(self.dbsc.labels_, dtype=bool)
			core_samples_mask[self.dbsc.core_sample_indices_] = True
			class_member_mask = (self.labels == k)

			xy = np.asarray(datapoints)[class_member_mask & core_samples_mask]
			plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col), markeredgecolor='k', markersize=14)

			xy = datapoints[class_member_mask & ~core_samples_mask]
			plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col), markeredgecolor='k', markersize=6)

		plt.title('Stuff')
		plt.xlabel('Angle')
		plt.ylabel('Distance')
		plt.show()
		return

	def obstacleVisualizer(self, data):
		solid_red = ColorRGBA()
		solid_red.r, solid_red.g, solid_red.b, solid_red.a = 1.0, 0.0, 0.0, 1.0 # Opaque red
		pointList = [data.position]

		if (data.position is not None):
			for theta in self.obstCoordDict.keys():
				pointList.append(Point( data.position.x + math.cos(theta), data.position.y + math.sin(theta), 0.0 ))

			obst_arrow = RVizMarker(
				rospy.get_rostime(), 
				None, 
				solid_red, 
				0, 
				Vector3( 0.1, 0.2, 0.2 ), 
				pointList )
			self.vizPub.publish( obst_arrow.marker )

	def exitHandler(self):
		# Stop robot and exit gracefully
		self.velPub.publish(self.stopVel)
		print "boop"
		return

	def run(self, data):
		warnings.filterwarnings("ignore")
		apf = APF()

		#While ros is running and bump sensor not triggered
		while ( ( not rospy.is_shutdown()) and (data.stopStatus == False) ):
			if data.ranges is not None:
				self.findObstacles(data.ranges)
				# self.laserscanVisualizer(self.lidarPoints)
				goalAngle = self.angleToGoal(data, Point(1.0, 1.0, 0))
				# print goalAngle # Sanity check
				# print self.obstCoordDict
				navAngle, minObstDistance = apf.bestAngle(self.obstCoordDict, goalAngle) # Desired angle, closest obstacle distance
				# apf.visualizePDF() # Visualizes navigational probabilities.
				self.navigate(navAngle, minObstDistance, 0.1)
				self.obstacleVisualizer(data)
				# self.velPub.publish(self.vel)
			self.r.sleep()
		self.velPub.publish(self.stopVel)
		return

if __name__ == '__main__':
	rospy.init_node('receive_message')
	data = NeatoCallbacks()
	node = ObstacleAvoid()
	node.run(data)